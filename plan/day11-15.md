# ⚔️ 第四阶段战术手册：高性能网络层 (Day 11 - 15)

**核心任务**：实现基于 Epoll 的 Reactor 网络模型，将单机引擎升级为网络服务器。
**技术难点**：Socket 编程、IO 多路复用 (Epoll)、非阻塞 IO、应用层协议设计。

---

## 📅 Day 11: Socket 编程入门 (Blocking IO)

**目标**：理解 Linux 网络编程基本流程，跑通最简单的“一问一答”。

### 1. 理论突击
* **Socket 四件套**：
    * `socket()`: 创建插座（买手机）。
    * `bind()`: 绑定 IP 和端口（插 SIM 卡）。
    * `listen()`: 开始监听（开机待机）。
    * `accept()`: 阻塞等待连接（接电话）。
* **文件描述符 (FD)**：在 Linux 下，一切皆文件，网络连接也是一个 int 类型的 FD。

### 2. 实战任务
* **新建文件**：`KVStore/src/simple_server.cpp` (这是临时的练手文件，不进最终项目)。
* **代码目标**：
    1.  启动服务监听 8080 端口。
    2.  使用 `telnet 127.0.0.1 8080` 连接。
    3.  服务端接收消息并打印，然后回发 "I received your message"。
* **局限性**：这时候还是阻塞模型 (BIO)，一次只能服务一个客户端。

---

## 📅 Day 12: IO 多路复用与 Epoll 基础

**目标**：解决“一次只能服务一个”的问题，理解 Epoll 为什么快。

### 1. 理论突击 (面试必问)
* **BIO vs NIO vs IO Multiplexing**：
    * **BIO**：傻等。
    * **NIO**：轮询（忙等）。
    * **Epoll**：事件通知（有事叫我）。
* **Epoll 核心 API**：
    * `epoll_create()`: 建个群。
    * `epoll_ctl()`: 把 socket 拉进群。
    * `epoll_wait()`: 等群里有人说话。

### 2. 实战任务
* **代码目标**：重写 `simple_server.cpp`，引入 Epoll。
* **流程**：
    1.  把 `listen_fd` 加入 Epoll 监控。
    2.  死循环调用 `epoll_wait`。
    3.  如果是 `listen_fd` 有动静 -> 调用 `accept` 建立新连接，并把新连接也加入 Epoll。
    4.  如果是其他 fd 有动静 -> 调用 `read` 读取数据。

---

## 📅 Day 13: 封装 Epoll 与 Reactor 模型雏形

**目标**：将杂乱的 C 语言风格 API 封装成 C++ 类，构建 Reactor 模型。

### 1. 架构设计
我们需要把网络层从 `main.cpp` 中剥离出来，建立独立的类。

### 2. 实战任务
* **新建文件**：`include/epoll.h`, `src/epoll.cpp`。
* **Class Epoll**：
    * `addFd(int fd, uint32_t events)`: 注册事件。
    * `wait(...)`: 等待事件，返回活跃的事件列表。
* **Class Socket** (可选): 封装 `bind`, `listen`, `accept`，让代码更优雅，支持 RAII 自动关闭连接。

---

## 📅 Day 14: 协议设计与存储引擎对接 (Integration)

**目标**：让网络层“听懂” KV 业务指令，并调用 `SkipList`。

### 1. 协议设计 (Protocol)
我们需要一种简单的文本协议（类似 Redis）：
* `SET key value`
* `GET key`
* `DEL key`

### 2. 实战任务
* **新建文件**：`include/server.h`, `src/server.cpp`。
* **逻辑链路**：
    1.  Epoll 收到数据 -> 读取到 buffer。
    2.  **Parser**：解析字符串，提取命令类型、Key、Value。
    3.  **Executor**：调用 `skipList->insert(key, value)` 等。
    4.  **Response**：根据返回值，构造 "OK" 或 "NOT FOUND" 发回给客户端。

---

## 📅 Day 15: 压力测试与 Bug 修复

**目标**：验证高并发下的稳定性，修复“粘包/拆包”等网络问题。

### 1. 客户端编写
* 编写一个简单的 `client.cpp`，循环发送随机指令。

### 2. 压力测试
* 同时启动 10 个 Client 进程，疯狂轰炸 Server。
* 观察 Server 是否会 Crash，内存是否飙升。

### 3. 常见 Bug 修复
* **粘包问题**：客户端发了 "SET A 1" 和 "GET A"，服务端可能一次性收到了 "SET A 1GET A"。需要简单的边界处理（比如按换行符 `\n` 切割）。
* **非阻塞读写**：`read` 返回 `EAGAIN` 怎么办？需要把没读完的数据存起来下次再读。

---

## 💡 队长锦囊：网络编程心态

1.  **别被报错吓倒**：网络编程会有各种奇奇怪怪的 error code (Broken pipe, Connection reset)，这很正常。
2.  **由简入繁**：Day 11 的阻塞版虽然简单，但它是理解 TCP 三次握手的基础，别跳过。
3.  **调试技巧**：学会用 `netstat -anp | grep 8080` 查看端口状态，用 `tcpdump` 抓包（进阶）。